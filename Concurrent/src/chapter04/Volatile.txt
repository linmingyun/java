 volatile用处说明

    在JDK1.2之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而随着JVM的成熟和优化，现在在多线程环境下volatile关键字的使用变得非常重要。
在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。
要解决这个问题，就需要把变量声明为volatile（也可以使用同步，参见http://blog.csdn.net/ns_code/article/details/17288243），这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下，各任务间共享的变量都应该加volatile修饰符。
Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较。
这样当多个线程同时与某个对象交互时，就必须注意到要让线程及时的得到共享成员变量的变化。而volatile关键字就是提示JVM：对于这个成员变量，不能保存它的私有拷贝，而应直接与共享成员变量交互。
volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。
使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。
由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。

按照以上的理论来分析，由于value变量不是volatile的，因此它在main线程中的改变不会被Thread-0线程（在main线程中新开启的线程）马上看到，因此Thread-0线程中的while循环不会直接退出，它会继续判断missedIt的值，由于missedIt是volatile的，当main线程中改变了missedIt时，Thread-0线程会立即看到该变化，那么if语句中的代码便得到了执行的机会，由于此时Thread-0依然没有看到value值的变化，因此，currValue的值为10，继续向下执行，进入同步代码块，因为进入前后要将该线程内的变量值与共享内存中的原始值对比，进行校准，因此离开同步代码块后，Thread-0便会察觉到value的值变为了50，那么后面的valueAfterSync的值便为50，最后从break跳出循环，结束Thread-0线程。

从结果中可以看出，Thread-0线程并没有进入while循环，说明Thread-0线程在value的值发生变化后，missedIt的值发生变化前，便察觉到了value值的变化，从而退出了while循环。这与理论上的分析不符，我便尝试注释掉value值发生改变与missedIt值发生改变之间的线程休眠代码Thread.sleep(5000)，以确保Thread-0线程在missedIt的值发生改变前，没有时间察觉到value值的变化。但执行的结果与上面大同小异（可能有一两行顺序不同，但依然不会打印出if语句中的输出信息）。

问题分析

在JDK1.7~JDK1.3之间的版本上输出结果与上面基本大同小异，只有在JDK1.2上才得到了预期的结果，即Thread-0线程中的while循环是从if语句中退出的，这说明Thread-0线程没有及时察觉到value值的变化。
这里需要注意：volatile是针对JIT带来的优化，因此JDK1.2以前的版本基本不用考虑，另外，在JDK1.3.1开始，开始运用HotSpot虚拟机，用来代替JIT。因此，是不是HotSpot的问题呢？这里需要再补充一点：
JIT或HotSpot编译器在server模式和client模式编译不同，server模式为了使线程运行更快，如果其中一个线程更改了变量boolean flag 的值，那么另外一个线程会看不到，因为另外一个线程为了使得运行更快所以从寄存器或者本地cache中取值，而不是从内存中取值，那么使用volatile后，就告诉不论是什么线程，被volatile修饰的变量都要从内存中取值。《内存栅栏》
但看了这个帖子http://segmentfault.com/q/1010000000147713（也有人遇到同样的问题了）说，尝试了HotSpot的server和client两种模式，以及JDK1.3的classic，都没有效果，只有JDK1.2才能得到预期的结果。
哎！看来自己知识还是比较匮乏，看了下网友给出的答案，对于非volatile修饰的变量，尽管jvm的优化，会导致变量的可见性问题，但这种可见性的问题也只是在短时间内高并发的情况下发生，CPU执行时会很快刷新Cache，一般的情况下很难出现，而且出现这种问题是不可预测的，与jvm, 机器配置环境等都有关。
